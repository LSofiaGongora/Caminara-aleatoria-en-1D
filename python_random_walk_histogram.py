# -*- coding: utf-8 -*-
"""python random_walk_histogram.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Zx9RZQ2ktFnIf0jiWifhFqpLxbfNnaxI
"""

import numpy as np
import matplotlib.pyplot as plt

def random_walk_1d(N):
    """
    Simulación de una caminata aleatoria en 1D de N pasos.
    Cada paso es de longitud a=1, con igual probabilidad de ir a la derecha (+1) o izquierda (-1).
    Se devuelve la posición final.
    """
    # Generar N pasos aleatorios: +1 (derecha) o -1 (izquierda)
    steps = np.random.choice([-1, 1], size=N)
    # Sumar todos los pasos para obtener la posición final
    x_final = np.sum(steps)
    return x_final

# Parámetros
N = 1000          # Número de pasos por caminata (N grande)
num_simulations = 10000  # Número de caminatas a simular

# Simular muchas caminatas
final_positions = []
for i in range(num_simulations):
    x_final = random_walk_1d(N)
    final_positions.append(x_final)

# Convertir a array de numpy para cálculos
final_positions = np.array(final_positions)

# Calcular la media y varianza de las posiciones finales
mean_x = np.mean(final_positions)
var_x = np.var(final_positions)
print(f"Media de las posiciones finales: {mean_x}")
print(f"Varianza de las posiciones finales: {var_x}")
print(f"Varianza teórica (a^2 * N): {N}")  # ya que a=1

# Teorema del límite central: distribución teórica gaussiana
# La posición final debería seguir N(0, a^2 * N) = N(0, N)
x_min = np.min(final_positions)
x_max = np.max(final_positions)
x_values = np.linspace(x_min, x_max, 1000)
# Función de densidad de probabilidad gaussiana
gaussian = (1 / np.sqrt(2 * np.pi * N)) * np.exp(-x_values**2 / (2 * N))

# Crear histograma
plt.figure(figsize=(10, 6))
# Histograma normalizado para comparar con la PDF
plt.hist(final_positions, bins=50, density=True, alpha=0.7, label='Histograma simulaciones')
# Graficar la gaussiana teórica
plt.plot(x_values, gaussian, 'r-', linewidth=2, label='Gaussiana teórica')
plt.title(f'Histograma de posiciones finales para N={N} pasos')
plt.xlabel('Posición final, x')
plt.ylabel('Densidad de probabilidad')
plt.legend()
plt.grid(True)
plt.show()

# Parámetros
N_values = [10, 20, 50, 100, 200, 500, 1000, 2000]  # Diferentes valores de N
num_simulations = 10000  # Número de caminatas para cada N

# Arrays para almacenar resultados
mean_x = []       # 〈x〉 para cada N
mean_x2 = []      # 〈x²〉 para cada N

# Simular para cada N
for N in N_values:
    final_positions = []
    for i in range(num_simulations):
        x_final = random_walk_1d(N)
        final_positions.append(x_final)

    final_positions = np.array(final_positions)
    mean_x.append(np.mean(final_positions))
    mean_x2.append(np.mean(final_positions**2))
    print(f"N = {N}: <x> = {mean_x[-1]:.4f}, <x^2> = {mean_x2[-1]:.4f}")

# Convertir a arrays numpy
N_values = np.array(N_values)
mean_x = np.array(mean_x)
mean_x2 = np.array(mean_x2)

# Graficar 〈x〉 vs N
plt.figure(figsize=(10, 6))
plt.plot(N_values, mean_x, 'bo-', label='<x>')
plt.axhline(0, color='r', linestyle='--', label='Teoría: <x>=0')
plt.xlabel('N (número de pasos)')
plt.ylabel('<x>')
plt.title('<x> vs N')
plt.legend()
plt.grid(True)
plt.show()

# Graficar 〈x²〉 vs N
plt.figure(figsize=(10, 6))
plt.plot(N_values, mean_x2, 'ro-', label='<x²> simulado')
plt.plot(N_values, N_values, 'k--', label='Teoría: <x²> = a²N (con a=1)')
plt.xlabel('N (número de pasos)')
plt.ylabel('<x²>')
plt.title('<x²> vs N')
plt.legend()
plt.grid(True)
plt.show()

# Ajuste lineal para determinar la constante de difusión
# Teoría: 〈x²〉 = 2 D t, pero t = N τ (si τ es el tiempo por paso)
# Como cada paso tiene longitud a=1 y tiempo τ=1, entonces 〈x²〉 = 2 D N
# Por lo tanto, la pendiente de 〈x²〉 vs N es 2D

# Ajuste lineal: 〈x²〉 = m * N + b
coefficients = np.polyfit(N_values, mean_x2, 1)
m = coefficients[0]  # Pendiente
b = coefficients[1]  # Intercepto

print(f"Pendiente (m) del ajuste <x²> = m * N + b: {m}")
print(f"Intercepto (b): {b}")

# La constante de difusión D = m / 2 (ya que 〈x²〉 = 2 D N)
D = m / 2
print(f"Constante de difusión D estimada: {D}")

# Graficar 〈x²〉 vs N con el ajuste lineal
plt.figure(figsize=(10, 6))
plt.plot(N_values, mean_x2, 'ro', label='<x²> simulado')
plt.plot(N_values, m * N_values + b, 'b-', label=f'Ajuste lineal:< x²> = {m:.4f} * N + {b:.4f}')
plt.xlabel('N (número de pasos)')
plt.ylabel('<x²>')
plt.title('<x²> vs N con ajuste lineal')
plt.legend()
plt.grid(True)
plt.show()