# -*- coding: utf-8 -*-
"""python random_walk_analysis.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1StmjnZGiPE9h8YPWHpy14DzYS6QuZbUG
"""

# random_walk_analysis.py
import numpy as np
import matplotlib.pyplot as plt

def random_walk_1d(N):
    steps = np.random.choice([-1, 1], size=N)
    return np.sum(steps)

# Parámetros
N_values = [10, 20, 50, 100, 200, 500, 1000, 2000]  # Diferentes valores de N
num_simulations = 10000  # Número de caminatas para cada N

# Arrays para almacenar resultados
mean_x = []       # 〈x〉 para cada N
mean_x2 = []      # 〈x²〉 para cada N

# Simular para cada N
for N in N_values:
    final_positions = []
    for i in range(num_simulations):
        x_final = random_walk_1d(N)
        final_positions.append(x_final)

    final_positions = np.array(final_positions)
    mean_x.append(np.mean(final_positions))
    mean_x2.append(np.mean(final_positions**2))
    print(f"N = {N}: <x> = {mean_x[-1]:.4f}, <x^2> = {mean_x2[-1]:.4f}")

# Convertir a arrays numpy
N_values = np.array(N_values)
mean_x = np.array(mean_x)
mean_x2 = np.array(mean_x2)

# Graficar 〈x〉 vs N
plt.figure(figsize=(10, 6))
plt.plot(N_values, mean_x, 'bo-', label='<x>')
plt.axhline(0, color='r', linestyle='--', label='Teoría: <x>=0')
plt.xlabel('N (número de pasos)')
plt.ylabel('<x>')
plt.title('<x> vs N')
plt.legend()
plt.grid(True)
plt.show()

# Graficar 〈x²〉 vs N
plt.figure(figsize=(10, 6))
plt.plot(N_values, mean_x2, 'ro-', label='<x²> simulado')
plt.plot(N_values, N_values, 'k--', label='Teoría: <x²> = a²N (con a=1)')
plt.xlabel('N (número de pasos)')
plt.ylabel('<x²>')
plt.title('<x²> vs N')
plt.legend()
plt.grid(True)
plt.show()

# Ajuste lineal para determinar la constante de difusión
# Teoría: 〈x²〉 = 2 D t, pero t = N τ (si τ es el tiempo por paso)
# Como cada paso tiene longitud a=1 y tiempo τ=1, entonces 〈x²〉 = 2 D N
# Por lo tanto, la pendiente de 〈x²〉 vs N es 2D

# Ajuste lineal: 〈x²〉 = m * N + b
coefficients = np.polyfit(N_values, mean_x2, 1)
m = coefficients[0]  # Pendiente
b = coefficients[1]  # Intercepto

print(f"Pendiente (m) del ajuste <x²> = m * N + b: {m}")
print(f"Intercepto (b): {b}")

# La constante de difusión D = m / 2 (ya que 〈x²〉 = 2 D N)
D = m / 2
print(f"Constante de difusión D estimada: {D}")

# Graficar 〈x²〉 vs N con el ajuste lineal
plt.figure(figsize=(10, 6))
plt.plot(N_values, mean_x2, 'ro', label='<x²> simulado')
plt.plot(N_values, m * N_values + b, 'b-', label=f'Ajuste lineal:< x²> = {m:.4f} * N + {b:.4f}')
plt.xlabel('N (número de pasos)')
plt.ylabel('<x²>')
plt.title('<x²> vs N con ajuste lineal')
plt.legend()
plt.grid(True)
plt.show()